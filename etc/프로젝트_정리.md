<h3>회원가입 컨트롤러</h3>

타임리프가 의존성에 들어있으면 스프링이 제공하는 자동설정에 의해서 (ThymeleafAutoConfiguration.java) templates 폴더 밑에서 `return "account/sign-up";` 에 해당하는 view 이름을 찾음.

+ 스프링 시큐리티를 의존성에 넣고 시작하면 sign-up페이지로 바로 이동할 수 없음. 로그인 필수. -> SecurityConfig 파일을 만들어서 해결

SecurityConfig.java 파일에 extends WebSecurityConfigurerAdapter 를 통해 WebSecurity 설정을 손쉽게 할 수 있도록 도와줌.

```java
public class SecurityConfig { // extends WebSecurityConfigurerAdapter를 상속 받으면 WebSecurity 설정을 손쉽게 할 수 있도록 도와줌. 그리고 configure 메소드를 Override 하여 설정하였지만, 개정이 되어 SecurityFilterChain을 bean 등록하는 것으로 바뀜.
```

`.mvcMatchers("/","/login","/sign-up")`처럼 작성하여 로그인 없이 접근할 수 있도록 설정

TEST CODE 작성

```java
package hello.springjpa.webapp.account;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

@SpringBootTest
@AutoConfigureMockMvc
class AccountControllerTest {

    @Autowired private MockMvc mockMvc;

    @DisplayName("회원 가입 화면 보이는지 확인")
    @Test
    void signUpForm() throws Exception {
        mockMvc.perform(get("/sign-up"))
                .andExpect(status().isOk())
                .andExpect(view().name("account/sign-up"));
    }
}
```

<hr>

<h3>회원가입 VIEW 생성</h3>

부트스트랩, 타임리프, 웹(HTML,CSS,JavaScript) 사용

`<a href="#" th:href="@{/login}">`

타임리프로 렌더링 하지 않을 때에도 html 으로 렌더링 되니까 그때 사용되라고 href를 작성해주기도 함

부트스트랩이 제공하는 폼 유효성 검사가 있음

needs-validation : submit 후에 유효성 검사

was-validated : submit 전에 유효성 검사

`required minlength="3" maxlength="20"` 태그에 작성한 내용을 기반으로 검사를 하고, 맞지 않으면 `class="invalid-feedback"` 에 작성한 내용을 보여줌. (처음엔 보이지 않음)

```javascript
// .html
<!-- form-validation -->
    (function () {
        'use strict';
        window.addEventListener('load', function () {
            // Fetch all the forms we want to apply custom Bootstrap validation styles to
            var forms = document.getElementsByClassName('needs-validation');

            // Loop over them and prevent submission
            Array.prototype.filter.call(forms, function (form) {
                form.addEventListener('submit', function (event) {
                    if (form.checkValidity() === false) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    form.classList.add('was-validated')
                }, false)
            })
        }, false)
    }())
```

[부트스트랩 참고](https://getbootstrap.com/docs/5.0/forms/validation/)

그리고 form으로 받을 데이터를 설정할 수 있음

```java
@Data
public class SignUpForm {
    @NotBlank
    @Length(min = 3, max = 20)
    @Pattern(regexp = "^[ㄱ-ㅎ가-힣a-z0-9_-]{3,20}$")
    private String nickname;
    
    @Email
    @NotBlank
    private String email;
    
    @NotBlank
    @Length(min = 8, max = 50)
    private String password;
}
/*Controller.java*/
...
	model.addAttribute(new SignUpForm());
//여기서 "signUpForm"을 명시하지 않은 이유는 클래스 이름과 같을 경우 자동적으로 camelCase가 적용되어 이름이 설정되기 때문.
...
```

+추가적으로 view에서 이미지를 띄우고 싶은데 보이지 않을 경우. 스프링 시큐리티를 살펴보면 됨. 마찬가지로 static 리소스들도 인증없이 보여지도록 설정하면 됨.

```java
/*SecurityConfig.java*/
@Bean
public WebSecurityCustomizer webSecurityCustomizer() {
    return (web) -> web.ignoring()
        .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
}
```

TEST CODE 작성

기존 코드에 `.andExpect(model().attributeExists("signUpForm"));` 를 추가하여 해당 애트리뷰트가 있는지 확인하면 됨.

<hr>

<h3>폼 서브밋</h3>

폼 검증에 JSR 303 애노테이션 검증(값의 길이, 필수값)을 할 수 있고 커스텀 검증(중복 이메일, 닉네임 여부 확인) 등 DB조회가 필요한 부분이 있음 ([* JSR 303 어노테이션은 빈 객체에 주입되는 값의 유효성 검사를 하기 위해 제공되는 어노테이션임](https://cookinghoil.tistory.com/82))

`@Valid SignUpForm signUpForm, Errors errors` 컨트롤러에서 @Valid를 사용하여 검사, 에러가 있으면 Errors에 담김

프론트와 백 둘 다 검증을 하는 이유는, 프론트에서 javascript 사용해서 바로 submit 할 수 있음 그래서 백에서도 꼭 검사를 해주는게 좋음

그래도 프론트에서 한 번 검증을 하고 넘어오면 서버 리소스를 절약할 수 있고 사용자에게 좀 더 빠르게 반응할 수 있어서 추가함

추가로 커스텀 검증을 진행 (SignUpFormValidator.java)

```java
@Component // Repository가 bean이고 bean을 주입받아야 하니까 같이 bean이 되어야 함, 명시적으로 넣어줘도 되지만 bean으로 등록해서 사용함
@RequiredArgsConstructor // lombok이 제공하는 어노테이션, final 타입 변수의 생성자를 만들어 줌, final 없으면 안 만들어 줌. 선별적으로 생성자를 만들 수 있음
public class SignUpFormValidator implements Validator {
    private final AccountRepository accountRepository;
    
    @Override
    public boolean supports(Class<?> clazz) {
        return clazz.isAssignableFrom(SignUpForm.class); // SignUpForm 타입의 인스턴스를 검사
    }

    @Override
    public void validate(Object target, Errors errors) {
        // 실제로 DB에서 검색해서 진행
        SignUpForm signUpForm = (SignUpForm) target;
        if(accountRepository.existsByEmail(signUpForm.getEmail())) {
            errors.rejectValue("email", "invalid.email", new Object[]{signUpForm.getEmail()}, "이미 사용중인 이메일 입니다.");
        }

        if(accountRepository.existsByNickname(signUpForm.getNickname())) {
            errors.rejectValue("nickname", "invalid.nickname", new Object[]{signUpForm.getNickname()}, "이미 사용중인 닉네임 입니다.");
        }
    }
}
```

Repository를 생성할 땐 `@Transactional(readOnly = true)` 추가하여 성능을 살짝 보완

만들어진 validator를 controller에서 사용

```java
/* 방법 1 메소드 내에 코드를 추가하여 사용해도 됨, 근데 조금 번거로울 수 있음*/
	signUpFormValidator.validate(signUpForm, errors);
    if(errors.hasErrors()) {
    	return "account/sign-up";
    }
/* 방법 2 InitBinder를 설정,  signUpForm 을 받을 때 303 검증도 하고, 추가한 validator도 사용 */
	@InitBinder("signUpForm")
    public void initBinder(WebDataBinder webDataBinder) {
        webDataBinder.addValidators(signUpFormValidator);
    }
```

<hr>

<h3>서브밋 처리</h3>

```java
Account account = Account.builder()
                .email(signUpForm.getEmail())
                .nickname(signUpForm.getNickname())
                .password(signUpForm.getPassword()) // TODO encoding 필요
                .studyCreatedByWeb(true)
                .studyEnrollmentResultByWeb(true)
                .studyUpdatedByWeb(true)
                .build();
Account newAccount = accountRepository.save(account); // 저장
```

<hr>

<h3>회원가입 테스트</h3>

TEST CODE 작성

```java
// AccountControllerTest.java
@DisplayName("회원 가입 처리 - 입력값 오류")
@Test
void signUpSubmit_with_wrong_input() throws Exception {
    mockMvc.perform(post("/sign-up")
                    .param("nickname", "test")
                    .param("email", "your..")
                    .param("password","12345")
                    .with(csrf())) // 없이 테스트를 진행하면 403 error 발생, 스프링 시큐리티로 인해 csrf 기능이 활성화 되었기 때문(* 타 사이트에서 내 사이트로 공격 폼 데이터를 보내는 기술을 방어하는 기능(hidden에 담긴 토큰으로 인증)), form 데이터 넘겨 주는 테스트에 필요
        .andExpect(status().isOk())
        .andExpect(view().name("account/sign-up"));
}

@DisplayName("회원 가입 처리 - 입력값 정상")
@Test
void signUpSubmit_with_correct_input() throws Exception {
    mockMvc.perform(post("/sign-up")
                    .param("nickname", "test")
                    .param("email", "your@email.com")
                    .param("password","12345678")
                    .with(csrf()))
        .andExpect(status().is3xxRedirection())
        .andExpect(view().name("redirect:/"));

    assertTrue(accountRepository.existsByEmail("your@email.com"));
    //메일이 잘 보내졌는지
    then(javaMailSender).should().send(any(SimpleMailMessage.class));
    //SimpleMailMessage.class 타입 아무거나 호출이 됐는지 확인.
}
```

<hr>

<h3>패스워드 인코딩</h3>

`PasswordEncoderFactories.createDelegatingPasswordEncoder()` 스프링 시큐리티가 기본으로 제공, 해싱 알고리즘 bcrypt를 사용함

보통 해싱을 사용할 때 salt를 사용, 비밀번호 평문만 해싱하지 않고 salt를 추가해서 해싱해도 bcrypt 알고리즘 특성상 salt 값이 매번 달라도 비밀번호를 검증할 수 있음

`BCryptPasswordEncoder.java` 에서 encode, matches 메소드를 살펴보면

```java
/* 인코딩 */
public String encode(CharSequence rawPassword) {
    if (rawPassword == null) {
        throw new IllegalArgumentException("rawPassword cannot be null");
    } else {
        String salt = this.getSalt();
        return BCrypt.hashpw(rawPassword.toString(), salt);
    }
}
/* 비밀번호 확인 */
public boolean matches(CharSequence rawPassword, String encodedPassword) {
    if (rawPassword == null) {
        throw new IllegalArgumentException("rawPassword cannot be null");
    } else if (encodedPassword != null && encodedPassword.length() != 0) {
        if (!this.BCRYPT_PATTERN.matcher(encodedPassword).matches()) {
            this.logger.warn("Encoded password does not look like BCrypt");
            return false;
        } else {
            return BCrypt.checkpw(rawPassword.toString(), encodedPassword);
            // 해당 코드에서 `return equalsNoEarlyReturn(hashed, hashpwforcheck(passwordb, hashed));` 내용을 보면 비밀번호 평문, 인코딩된 비밀번호를 해싱하면 인코딩된 비밀번호가 나옴. 알고리즘의 특성임. 그렇기에 salt 값이 매번 달라져도 괜찮음
        }
    } else {
        this.logger.warn("Empty encoded password");
        return false;
    }
}
```

이렇게 제공되는 패스워드 인코더를 사용

```java
@Configuration
public class AppConfig {

    @Bean // 사용자가 직접 정의한 것이 아닌 외부 라이브러리 또는 설정을 위한 클래스를 bean 으로 등록
    public PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }
}
```

Bean은 스프링 컨테이너가 생성한 객체 (스프링 컨테이너는 객체를 생성하고 의존성을 주입하는 역할을 한다)

그리고 bean을 사용하기 위해 @Component , @Configuration 을 설정했었음

```java
@Configuration
public static class Config {
    @Bean
    public SimpleBean simpleBean() {
        return new SimpleBean();
    }
    @Bean
    public SimpleBeanConsumer simpleBeanConsumer() {
        return new SimpleBeanConsumer(simpleBean());
    }
}
@Component
public static class Config {
    @Bean
    public SimpleBean simpleBean() {
        return new SimpleBean();
    }
    @Bean
    public SimpleBeanConsumer simpleBeanConsumer() {
        return new SimpleBeanConsumer(simpleBean());
    }
}
// 둘은 비슷하게 생겼지만 다르게 작동함
// Configuration은 스프링 컨텍스트에 등록된 SimpleBean()을 반환
// Component는 새로 생성된 Bean이 반환
```

![1663768161234](https://user-images.githubusercontent.com/43261300/192646559-539acc05-6724-48a1-bf70-f87d451f7749.png)

bean은 한 번씩 호출되며 컨텍스트에 저장됨. component bean이 2번 표시된 것은 생성이 되고 저장되기 위해 호출될 때 한 번 더 표시가 되었기 때문

그래서 @Component는 개발자가 직접 작성한 클래스를 빈으로 등록하고 싶을 때 사용 (개발자가 직접 제어 가능), @Configuration은 개발자가 직접 제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 Bean으로 등록할 때 사용, 1개 이상의 @Bean을 제공하는 클래스에 사용 (개발자가 직접 제어 불가능) 하기도 한다. [참고]([봄 @Configuration 대 @Component (dimafeng.com)](http://dimafeng.com/2015/08/29/spring-configuration_vs_component/))

등록한 passwordEncoder는 `.password(passwordEncoder.encode(signUpForm.getPassword()))` 이렇게 사용하면 됨

TEST CODE 작성

```java
Account account = accountRepository.findByEmail("your@email.com");
assertNotNull(account);
assertNotEquals(account.getPassword(), "12345678");
```

<hr>
<h3>회원가입 인증 메일 확인</h3>

인증 메일 확인 도중 token 값이 null 로 들어오는 것을 확인

회원정보를 저장하고 token 값을 생성했는데 여기서 문제가 발생

```java
//AccountService.java
@Transactional // 3
public void processNewAccount(SignUpForm signUpForm) {
    Account newAccount = saveNewAccount(signUpForm); // 1.account 저장한 후
    newAccount.generateEmailCheckToken(); // 2.token 생성 중
    sendSignUpConfirmEmail(newAccount);
}

private Account saveNewAccount(SignUpForm signUpForm) {
    Account account = Account.builder()
        .email(signUpForm.getEmail())
        .nickname(signUpForm.getNickname())
        .password(passwordEncoder.encode(signUpForm.getPassword()))
        .studyCreatedByWeb(true)
        .studyEnrollmentResultByWeb(true)
        .studyUpdatedByWeb(true)
        .build();
    return accountRepository.save(account); // 1-1
}
```

1 account 저장할 때 1-1 까지 JPA persist 상태임. account 저장하고 return 된 객체는 detached 상태가 됨

2 토큰을 생성하고 저장할 때  newAccount는 detached 상태이기에 변경사항이 저장되지 않음

3 해당 문제를 해결하기 위해서는 트랜잭션을 추가해주면 됨. 그러면 save 하고 빠져나와도 persist 상태가 유지됨

그리고 트랜잭션이 종료될 때 현 상태를 DB에 싱크함.

TEST CODE 작성

`assertNotNull(account.getEmailCheckToken());` 추가해서 토큰 값 저장 확인

```java
//AccountControllerTest.java
@DisplayName("인증 메일 확인 - 입력값 오류")
@Test
void checkEmailToken_with_wrong_input() throws Exception {
    mockMvc.perform(get("/check-email-token")
                    .param("token","asdfasdf")
                    .param("email","your@email.com"))
        .andExpect(status().isOk())
        .andExpect(model().attributeExists("error"))
        .andExpect(view().name("account/checked-email"));
}

@DisplayName("인증 메일 확인 - 입력값 정상")
@Test
void checkEmailToken() throws Exception {
    Account account = Account.builder()
        .email("your@email.com")
        .password("asdfasdf")
        .nickname("usernick")
        .build();

    Account newAccount = accountRepository.save(account);
    newAccount.generateEmailCheckToken();

    mockMvc.perform(get("/check-email-token")
                    .param("token",newAccount.getEmailCheckToken()) // 만약 테스트 중 여기서 error가 난다면 @DataJpaTest 아니라 @SpringBootTest로 했을 때 트랜잭션이 없어서 발생할 수 있음
                    .param("email",newAccount.getEmail()))
        .andExpect(status().isOk())
        .andExpect(model().attributeDoesNotExist("error"))
        .andExpect(model().attributeExists("nickname"))
        .andExpect(model().attributeExists("numberOfUser"))
        .andExpect(view().name("account/checked-email"));
}
```

<hr>

<h3>로그인</h3>

스프링 시큐리티에는 스프링 컨텍스트 홀더가 있는데, 여기에 context를 들고 있음 `SecurityContext context = SecurityContextHolder.getContext();`

그리고 context에 인증정보를 설정할 수 있음

```java
public void login(Account account) {
    UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(
        account.getNickname(), account.getPassword(), 
        List.of(new SimpleGrantedAuthority("ROLE_USER")) //권한 목록을 받아줘서 List 임
    ); //순서대로 principal, password, auth

    SecurityContextHolder.getContext().setAuthentication(token);
}
```

원래 UsernamePasswordAuthenticationToken는 AuthenticationManager 내부에서 사용하라고 만들어 놓은 생성자임

```java
// 사용 예시
public void login(Account account) {
    UsernamePasswordAuthenticationToken token1 = new UsernamePasswordAuthenticationToken(
        "사용자가 작성한 유저이름", "사용자가 작성한 평문 비밀번호"
    );
    Authentication authenticate = authenticationManager.authenticate(token1); // 인증과정을 거쳐
    SecurityContextHolder.getContext().setAuthentication(authenticate); // 저장
}
```

근데 그냥 토큰만들고 auth까지 다 주입하고 context에 세팅할거임, 왜냐면 plainPassword를 사용하지 않기 때문임. 정석 로그인할 때만 사용하는 메소드가 아니라 이메일 확인 후 자동로그인 할 때는 plainPassword가 없어서 사용할 수 없음.

TEST CODE 작성

`.andExpect(unauthenticated());` , `.andExpect(authenticated().withUsername("usernick"));` 스프링 시큐리티가 있을 때엔 mockMvc에 추가되는 기능들이 있음. 그중 하나가 with(csrf()) 임. (form 테스트에 사용), 그리고 또 하나가 해당 코드임. 인증이 된 사용자인지 아닌지 확인.

<hr>

<h3>네비게이션 메뉴</h3>

```xml
<dependency>
    <groupId>org.thymeleaf.extras</groupId>
    <artifactId>thymeleaf-extras-springsecurity5</artifactId>
</dependency>
```

```html
<html xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
```

위의 코드를 추가하면 form 에서 인증여부에 따라 접근을 제한할 수 있음

```html
<!-- .html, 네비게이션 메뉴 -->
<ul>
    <li sec:authorize="!isAuthenticated()">
        <a>로그인</a>
    </li>
    <li sec:authorize="!isAuthenticated()">
        <a>회원가입</a>
    </li>       
    <li sec:authorize="isAuthenticated()">    
        <a>프로필</a>
    </li>
</ul>
```

<hr>

<h3>뷰 중복 코드 제거</h3>

[타임리프가 제공하는 fragment 사용]([Tutorial: Using Thymeleaf](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#including-template-fragments))

```html
<!-- fragments.html , 코드를 모아놓을 html -->
<!-- footer -->
<footer th:fragment="footer">
        <a>About</a>
        <a>Contact Us</a>
</footer>
<!-- .html , footer가 필요한 html -->
<footer th:replace="fragments.html :: footer"></footer>
<!-- fragment를 찾을 때 상대경로를 찾는게 아님, view 이름으로 resource를 찾음 -->
```

<hr>

<h3>현재 인증된 사용자 점보 참조</h3>

스프링 시큐리티가 지원하는 웹 MVC 기능 중 하나

@AuthenticationPrincipal 어노테이션을 제공해주는데 [여기서 Principal은 로그인 할 때 넣었던 첫 번째 파라미터임.](#로그인)

`@AuthenticationPrincipal(expression = "#this == 'anonymousUser' ? null : account")` 그리고 SpEL(스프링 표현언어) 를 사용해서 Principal 내부 정보에 접근할 수 있음, 인증 정보가 있으면 account 를 넣어주고 아니면 null 을 넣음

```java
@Controller
public class MainController {
    @GetMapping("/")
    public String home(@CurrentUser Account account, Model model) {
        //@AuthenticationPrincipal 가 아닌 @CurrentUser로 사용 할거고, 반환 값을 Account 타입을 받고 싶은거야. (익명 사용자면 null)
        if(account != null) {
            model.addAttribute(account);
        }
        return "index";
    }
}
```

위 처럼 사용하려면 @CurrentUser 어노테이션을 만들어야 함

```java
@Retention(RetentionPolicy.RUNTIME) // 런타임까지 유지하고
@Target(ElementType.PARAMETER) // 파라미터에만 붙일 수 있고
@AuthenticationPrincipal(expression = "#this == 'anonymousUser' ? null : account") // SpEL 사용하여 정의, 현재 사용자가 로그인 하지 않은 익명 사용자면 null, 인증된 사용자면 account를 꺼내서 담아줌
public @interface CurrentUser {
}
```

근데 로그인할 때 사용한 principal 에는 account 가 없음, 스프링 시큐리티가 다루는 user 정보와 사용되는 도메인의 user 정보 사이를 연결하는 어댑터 같은 클래스가 필요

```java
@Getter
public class UserAccount extends User { // 여기 User는 스프링 시큐리티에서 오는 거
    private Account account; // 사용되는 도메인 user 정보, 이때 SpEL에 적은 이름과 같아야 함

    public UserAccount(Account account) {
        super(account.getNickname(), account.getPassword(), List.of(new SimpleGrantedAuthority("ROLE_USER")));
        this.account = account;
    }
}
```

위 클래스를 사용하여 로그인할 때,

```java
public void login(Account account) {
    UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(
        new UserAccount(account) // principal에 담아주면 됨
        , account.getPassword(), List.of(new SimpleGrantedAuthority("ROLE_USER"))
    );

    SecurityContextHolder.getContext().setAuthentication(token);
}
```

<hr>

<h3>로그인 / 로그아웃</h3>

스프링 시큐리티가 제공해주는 거 사용

```java
// SecurityConfig.java
http.formLogin()
    .loginPage("/login")  // 커스텀한 로그인 화면 이동
    .permitAll();

http.logout()
    .logoutSuccessUrl("/"); // 로그아웃 성공 후 이동 URL
// Controller.java
@GetMapping("/login")
public String login() {
    return "login";
}
```

로그인 화면을 생성하면 `<form th:action="@{/login}" method="post">` 폼 요청을 시큐리티가 처리해 줌, 핸들러를 따로 만들지 않아도 됨

이때, 디비에 저장된 정보를 활용하여 처리하기에 조회할 수 있는 UserDetailsService를 만들어야 함

```java
//AccountService.java
public class AccountService implements UserDetailsService { // 인터페이스 구현 필요
    @Transactional(readOnly = true)
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        // 로그인에 필요한 정보 조회
        Account account = accountRepository.findByEmail(email);
        if (account == null) {
            throw new UsernameNotFoundException(email);
        }

        return new UserAccount(account); // 위에서 만든 principal에 해당하는 객체를 넘기면 됨
    }
}
// service는 bean으로 등록되어 있기에 security에 설정하지 않아도 자동으로 가져다 사용
```

TEST CODE 작성

```java
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.redirectedUrl;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
class MainControllerTest {
	//test에선 @RequiredArgsConstructor를 스프링에서 주입하기 전에 junit이 먼저 개입하여 생성자에 다른 인스턴스를 주입하려 하기에 사용할 수 없음
    @Autowired MockMvc mockMvc;
    @Autowired AccountService accountService;
    @Autowired AccountRepository accountRepository;
    
    @BeforeEach
    void beforeEach() {
        SignUpForm signUpForm = new SignUpForm();
        signUpForm.setNickname("user");
        signUpForm.setEmail("user@gmail.com");
        signUpForm.setPassword("asdfasdf");
        accountService.processNewAccount(signUpForm);
    }
    
    @AfterEach // BeforeEach는 테스트가 실행될 때 한 번씩 실행, 정보가 중복되는 문제가 발생하기에 삭제해 줌
    void AfterEach() {
        accountRepository.deleteAll();
    }
    
    @DisplayName("이메일 로그인 성공")
    @Test
    void login_with_email() throws Exception {
        mockMvc.perform(post("/login")
                        .param("username", "user@gmail.com")
                        .param("password","asdfasdf")
                        .with(csrf()))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"))
                .andExpect(authenticated().withUsername("user"))
        ;
    }
    
    @WithMockUser // 임의로 계정을 넣어줌
    @DisplayName("로그아웃")
    @Test
    void logout() throws Exception {
        mockMvc.perform(post("/logout")
                        .with(csrf()))
                .andExpect(status().is3xxRedirection())
            	.andExpect(redirectedUrl("/"))
                .andExpect(unauthenticated());
    }
}
```

<hr>

<h3>로그인 기억하기</h3>

애플리케이션에서 로그인 하면 세션 아이디가 생성됨, 세션 아이디가 웹 브라우저와 서버 사이의 연결 고리임. 아이디에 해당하는 세션 메모리는 서버에 존재함

만약 서버에 객체가 없거나 웹에서 키값을 보내지 않으면 세션에 넣었던 정보는 무의미해짐 (세션을 지우거나, 서버를 재시동 하거나)

스프링 부트의 톰캣 서버는 기본적으로 세션 정보를 30분 가지고 있음 (오랜 시간으로 설정할 수 있지만 메모리 누수 방지를 위해 적당하게 설정하기)

그래도 로그인이 풀리지 않길 원한다면 스프링 시큐리티가 제공하는 rememberMe를 사용하면 됨, 세션아이디 외 쿠키에 인증정보를 담아두는 방법, 쿠키는 세션아이디가 없거나 만료됐을 때 사용되고 로그인이 성공되면 다시 세션아이디와 쿠키가 발급됨

문제는 이 쿠키를 다른 사람이 알게되면 계정을 뺏기는 것과 같은 단점이 있음, 그래서 스프링 시큐리티에서 제공하는 것이 시리즈 값임. 유저 정보, 매번 바뀌는 토큰 값, 고정된 시리즈 값을 한 번에 해싱함. 쿠키 값을 탈취당해도 사용자가 접속했을 때 토큰 값이 달라져 있으면 탈취된 계정으로 판단하여 다시 로그인 화면을 리턴함. 해커가 가져간 쿠키 값도 사용하지 못하고 로그인 화면을 보여줌, 유저 정보는 토큰 값과 시리즈 값이 함께 해싱되었기에 알아내기 힘듦, 이런 방법으로 계정을 보호할 수 있음

```java
// SecurityConfig.java
http.rememberMe()
    .userDetailsService(userDetailsService) // tokenRepository 사용할 때 설정
    .tokenRepository(tokenRepository()); // 유저정보, 토큰, 시리즈 값을 조합해서 만든 값을 디비에 저장

@Bean
public PersistentTokenRepository tokenRepository() {
    // JDBC 기반의 token repository 구현체
    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); // JdbcTokenRepositoryImpl가 사용하는 테이블 필요함
    jdbcTokenRepository.setDataSource(dataSource); // jdbc는 dataSource가 필요
    return jdbcTokenRepository;
}
```

```java
//JdbcTokenRepositoryImpl.java 를 보면
public class JdbcTokenRepositoryImpl extends JdbcDaoSupport implements PersistentTokenRepository {
    public static final String CREATE_TABLE_SQL = "create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null)"; // 테이블 정보 확인 가능
...
// persistent_logins 테이블 생성
@Table(name = "persistent_logins")
@Entity @Getter @Setter
public class PersistentLogins {

    @Id
    @Column(length = 64)
    private String series;

    @Column(nullable = false, length = 64)
    private String username;

    @Column(nullable = false, length = 64)
    private String token;

    @Column(name = "last_used", nullable = false, length = 64)
    private LocalDateTime lastUsed;

}
```

```html
<!-- login.html , 로그인할 때 체크박스 필요, 기본으로 정해진 값이 있음 (remember-me) -->
<div class="form-group form-check">
    <input type="checkbox" class="form-check-input" id="rememberMe" name="remember-me" checked>
    <label class="form-check-label" for="rememberMe" aria-describedby="rememberMeHelp">로그인 유지</label>
</div>
```

<hr>

<h3>Open EntityManager In View 필터</h3>

JPA EntityManage (영속성 컨텐스트 : 디비에서 읽어온 객체를 직접 관리, 트랜잭션 범위 안 persist 상태 객체를 관리하다 끝나면 변경사항을 디비에 반영, update 발생) 등을 처리하여 전체 프로세스에 바인딩 시키는 필터. 스프링부트가 기본적으로 설정

즉, 데이터 변경이 일어나는 메소드는 트랜잭션으로 관리 필요, 서비스에서 트랜잭션 관리가 되면 영속성 컨텍스트는 view 렌더링이 끝날 때 끝남, 뷰 렌더링에도 영속성 컨텍스트를 통해 조회가 가능해지며 해당 기능을 필터가 제공

<hr>
<h3>프로필</h3>

```java
//form에서 사용할 프로필 정보
@Data
public class Profile {
    @Length(max = 35)
    private String bio;
    @Length(max = 50)
    private String url;
    @Length(max = 50)
    private String occupation;
    @Length(max = 50)
    private String location;

    public Profile (Account account) {
        this.bio = account.getBio();
        this.url = account.getUrl();
        this.occupation = account.getOccupation();
        this.location = account.getLocation();
    }
}
//AccountSettingsController.java
@GetMapping("/account/settings/profile")
public String profileUpdateForm(@CurrentUser Account account, Model model) {
    model.addAttribute(account);
    model.addAttribute(new Profile(account));
    return "account/settings/profile";
}
@PostMapping("/account/settings/profile")
public String updateProfile(@CurrentUser Account account, @Valid Profile profile, Errors errors, Model model) {
    if(errors.hasErrors()) {
        model.addAttribute(account);
        return "account/settings/profile";
    }
    accountService.updateProfile(account,profile);
    return "redirect:/account/settings/profile";
}
//AccountService.java
public void updateProfile(Account account, Profile profile) {
    account.setUrl(profile.getUrl());
    account.setOccupation(profile.getOccupation());
    account.setLocation(profile.getLocation());
    account.setBio(profile.getBio());
}
```

현 상황에서 @PostMapping이 되며 profile 바인딩할 때 nullPointException 발생함, 스프링MVC가 모델을 받아올 때 Profile 인스턴스를 만들고 주입을 하는데 Profile에 있는 생성자를 가져다 쓰는 순간, account가 없기 때문임

그래서 @NoArgsConstructor를 추가해줘야 함, 아니면 기본 생성자를 생성하던가

또 한 가지, updateProfile 메소드는 실제로 저장되지 않음

저장하려는 account는 persist 상태가 아니기 때문, 트랜잭션으로 관리되고 있는 데이터가 아닌 세션에 담겨있던 principal 정보일 뿐임. 이미 트랜잭션이 끝난 데이터를 읽어온 것 (detached), 데이터가 변경되어도 디비와 싱크를 맞추지 않음

이런 경우엔 `accountRepository.save(account);` 를 사용하여 싱크를 맞추면 됨. save를 하면 아이디 값을 찾아 존재하면 merge 함

TEST CODE 작성

```java
// AccountSettingsControllerTest.java
@DisplayName("프로필 수정하기 - 입력값 정상")
@Test
void updateProfile() throws Exception {
    String bio = "짧은 소개 수정하는 경우";
    mockMvc.perform(post(AccountSettingsController.SETTINGS_PROFILE_URL)
                    .param("bio",bio)
                    .with(csrf()))
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl(AccountSettingsController.SETTINGS_PROFILE_URL))
        .andExpect(flash().attributeExists("message"));

    Account account = accountRepository.findByNickname("usernick");
    assertEquals(bio, account.getBio());
}
```

여기에 요청을 보낼 때 어떤 유저가 보내는지 설정 필요 [@WithMockUser](https://docs.spring.io/spring-security/reference/5.6.5/servlet/test/method.html#test-method-withmockuser) 가 있고, 진짜 DB에 있는 정보를 사용하고 싶을 땐, [@WithUserDetails](https://docs.spring.io/spring-security/reference/5.6.1/servlet/test/method.html#test-method-withuserdetails) 를 사용하면 됨

```java
// AccountSettingsControllerTest.java
@BeforeEach
void beforeEach() {
    SignUpForm signUpForm = new SignUpForm();
    signUpForm.setNickname("usernick");
    signUpForm.setEmail("user@gmail.com");
    signUpForm.setPassword("asdfasdf");
    accountService.processNewAccount(signUpForm);
}
@WithUserDetails(value="usernick", setupBefore = TestExecutionEvent.TEST_EXECUTION)
```

<hr>

<h3>패스워드</h3>

```java
// form 으로 받을 값은 2개, 새로운 패스워드-패스워드 확인
@Data
public class PasswordForm {
    @Length(min = 8, max = 50)
    private String newPassword;

    @Length(min = 8, max = 50)
    private String newPasswordConfirm;
}
// 2개의 값이 동일한지 확인하는 Validator (다른 bean을 사용하지 않으니 bean으로 등록하지 않아도 됨, 그냥 new 사용)
public class PasswordFormValidator implements Validator {
    @Override
    public boolean supports(Class<?> clazz) {
        return PasswordForm.class.isAssignableFrom(clazz);
    }
    @Override
    public void validate(Object target, Errors errors) {
        PasswordForm passwordForm = (PasswordForm) target;
        if (!passwordForm.getNewPassword().equals(passwordForm.getNewPasswordConfirm())) {
            errors.rejectValue("newPassword", "wrong.value","입력한 새 패스워드가 일치하지 않습니다.");
        }
    }
}
//AccountSettingsController.java
@InitBinder("passwordForm")
public void initBinder(WebDataBinder webDataBinder) {
    webDataBinder.addValidators(new PasswordFormValidator()); // new
}
```

TEST CODE 작성

```java
//AccountSettingsControllerTest.java
@WithAccount("usernick")
@DisplayName("패스워드 수정 - 입력값 정상")
@Test
void updatePassword() throws Exception {
    mockMvc.perform(post(AccountSettingsController.SETTINGS_PASSWORD_URL)
                    .param("newPassword","asdfasdf")
                    .param("newPasswordConfirm","asdfasdf")
                    .with(csrf()))
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl(AccountSettingsController.SETTINGS_PASSWORD_URL))
        .andExpect(flash().attributeExists("message"));

    Account account = accountRepository.findByNickname("usernick");
    assertTrue(passwordEncoder.matches("asdfasdf",account.getPassword()));
}

@WithAccount("usernick")
@DisplayName("패스워드 수정 - 입력값 에러 - 패스워드 불일치")
@Test
void updatePassword_error() throws Exception {
    mockMvc.perform(post(AccountSettingsController.SETTINGS_PASSWORD_URL)
                    .param("newPassword","asdfasdf")
                    .param("newPasswordConfirm","asdfqwer")
                    .with(csrf()))
        .andExpect(status().isOk())
        .andExpect(view().name(AccountSettingsController.SETTINGS_PASSWORD_VIEW_NAME))
        .andExpect(model().attributeExists("account"))
        .andExpect(model().attributeExists("passwordForm"))
        .andExpect(model().hasErrors());
}
```

<hr>

<h3>ModelMapper</h3>

```java
// AccountService.java
public void updateProfile(Account account, Profile profile) {
    account.setUrl(profile.getUrl());
    account.setOccupation(profile.getOccupation());
    account.setLocation(profile.getLocation());
    account.setBio(profile.getBio());
    account.setProfileImage(profile.getProfileImage());
    accountRepository.save(account);
}
```

위의 코드를 ModelMapper (: 객체의 프로퍼티를 다른 객체의 프로퍼티로 매핑해주는) 유틸리티를 적용하여 간결하게 수정 

```xml
<!-- pom.xml , 의존성 추가 -->
<dependency>
    <groupId>org.modelmapper</groupId>
    <artifactId>modelmapper</artifactId>
    <version>3.0.0</version>
</dependency>
```

```java
// AppCongif.java , bean 등록
@Bean
public ModelMapper modelMapper() {
    ModelMapper modelMapper = new ModelMapper();
    // 매핑되는 것을 잘 찾지 못할 수 있음 (ex, Email 과 createdByEmail 을 같은 것으로 인식)
    // UNDERSCORE가 아니면 하나의 프로퍼티로 간주하도록 설정 
    modelMapper.getConfiguration()
        .setDestinationNameTokenizer(NameTokenizers.UNDERSCORE)
        .setSourceNameTokenizer(NameTokenizers.UNDERSCORE);
    return modelMapper;
}
// AccountService.java
private final ModelMapper modelMapper;
public void updateProfile(Account account, Profile profile) {
	// map 메소드를 활용, 소스에 있는 데이터를 데스티네이션으로 복사
    modelMapper.map(profile, account); // profile을 account로 복사
    accountRepository.save(account);
    // 이름이 일치하고 프로퍼티가 매핑이 된다는 가정하에.
}
```

[참고](http://modelmapper.org/getting-started/)

[프로필](#프로필) 에서 작성했던 코드도 수정해보면,

```java
// AccountSettingsController.java
model.addAttribute(new Profile(account));
// 위 코드에 modelMapper를 사용
model.addAttribute(modelMapper.map(account, Profile.class));
// 그리고 profile에 생성자를 지워 코드를 간결하게 만들 수 있음
```

<hr>

<h3>관심주제</h3>

ManyToMany, Account에서 Tag(관심주제)를 참조하는 단방향으로 설정

```java
// Account.java
@ManyToMany
private Set<Tag> tags = new HashSet<>(); // 비어있는 컬렉션으로 세팅해주는게 좋음, null에 대해 안전함
```

[참고, List와 Set의 차이](https://hyunsoori.tistory.com/13)

릴레이션 DB에는 ManyToMany 개념이 없음, 전부 1:1, 1:N 방향

<table><tr><td>Account</td><td> <- Account_Tag -> </-Account_Tag-></td><td>Tag</td></tr></table>

- 조인 테이블을 사용해서 다대다 관계를 표현
- Account_Tag 에서 Account의 PK참조
- Account_Tag 에서 Tag 의 PK참조

SQL 확인

```properties
# 개발할 때에만 create-drop 또는 update를 사용하고 운영 환경에서는 validate를사용
spring.jpa.hibernate.ddl-auto=create-drop
# 개발시 SQL 로깅을 하여 어떤 값으로 어떤 SQL이 실행되는지 확인
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

프론트에서 사용할 라이브러리 , [Tagify](https://yaireo.github.io/tagify/) (npm install @yaireo/tagify)

```html
<!-- .html -->
<!-- tagify -->
<link rel="stylesheet" href="/node_modules/@yaireo/tagify/dist/tagify.css">
<style>
    .tagify--outside{
        border: 0;
        width: 100%;
    }
    .tagify--outside .tagify__input{
        order: -1;
        flex: 100%;
        border: 1px solid var(--tags-border-color);
        margin-bottom: 1em;
        transition: .1s;
    }
    .tagify--outside .tagify__input:hover{ border-color:var(--tags-hover-border-color); }
    .tagify--outside.tagify--focus .tagify__input{
        transition:0s;
        border-color: var(--tags-focus-border-color);
    }
</style>

<input id="tags" type="text" name="tags" class="tagify--outside" aria-describedby="tagHelp"/>

<script src="/node_modules/@yaireo/tagify/dist/tagify.min.js"></script>
<script type="application/javascript" th:inline="javascript">
    $(function() {
        function tagRequest(url, tagTitle) {
            $.ajax({
                dataType: "json",
                autocomplete: {
                    enabled: true,
                    rightKey: true,
                },
                contentType: "application/json; charset=utf-8",
                method: "POST",
                url: "/account/settings/tags" + url,
                data: JSON.stringify({'tagTitle': tagTitle})
            }).done(function (data, status) {
                console.log("${data} and status is ${status}");
            });
        }

        function onAdd(e) {
            tagRequest("/add", e.detail.data.value);
        }

        function onRemove(e) {
            tagRequest("/remove", e.detail.data.value);
        }

        var input = document.querySelector('input[name=tags]')
        var tagify = new Tagify(input, {
            dropdown : {
                enabled: 1, // suggest tags after a single character input
            } // map tags
        });
        tagify.on("add", onAdd);
        tagify.on("remove", onRemove);
    });
</script>
```

<hr>

<h3>관심주제 컨트롤러</h3>

Ajax 요청을 받을 때 Controller 는

```java
@PostMapping("/account/settings/tags/add")
@ResponseBody
public ResponseEntity addTag(@CurrentUser Account account, @RequestBody TagForm tagForm)  { // data는 요청 본문에 들어오니까 @RequestBody를 사용, 데이터를 받아줄 Form 생성 (tagTitle)
    String title = tagForm.getTagTitle();
    Tag tag = tagRepository.findByTitle(title);
    if(tag == null) {
        tag = tagRepository.save(Tag.builder().title(tagForm.getTagTitle()).build());
    }
    accountService.addTag(account, tag);
    return ResponseEntity.ok().build(); // 응답도 ajax 요청이라 @ResponseBody 로 응답의 본문에 String이 아닌 ResponseEntity로 ResponseEntity.ok().build();를 리턴해줘야 함
}
// AccountService.java
// 그리고 addTag 메소드에선
public void addTag(Account account, Tag tag) {
    //현재 account 객체는 detached 상태이기에 ToMany 관계인 tag 값들이 전부 null임
    //account 객체 다시 로딩 필요. Lazy 로딩도 persist 상태만 가능함
    Optional<Account> byId = accountRepository.findById(account.getId());
    byId.ifPresent(a -> a.getTags().add(tag)); //있으면 추가. 없으면 아무일도 일어나지 않음
}
```

여기까지만 하면 403 error가 발생, ajax 에서 Post 요청을 보내는데, 모든 post 요청에는 csrf 토큰이 필요

```html
<script type="application/javascript" th:inline="javascript">
    $(function() {
        var csrfToken = /*[[${_csrf.token}]]*/ null;
        var csrfHeader = /*[[${_csrf.headerName}]]*/ null;
        $(document).ajaxSend(function (e, xhr, options) {
            xhr.setRequestHeader(csrfHeader, csrfToken);
        });
    });
</script>
<!-- th:inline="javascript"를 쓰면 자바스크립트 코드 안에서 특정한 모델에 들어있는 정보 조회 가능, csrf 토큰은 항상 조회가 가능함 (스프링 시큐리티를 타임리프랑 같이 쓸 경우) -->
```

[Ajax 호출시 CSRF 토큰 전달하는 방법 참고](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#servlet-csrf-include-ajax)

<hr>

<h3>태그 목록 가져오기</h3>

저장된 TAG 목록을 가져오는 경우

```java
//AccountService.java
public Set<Tag> getTags(Account account) {
    Optional<Account> byId = accountRepository.findById(account.getId());
    return byId.orElseThrow().getTags(); // 없으면 error, 있으면 tag
}
//AccountSettingsController.java
@GetMapping("/account/settings/tags")
public String updateTags(@CurrentUser Account account, Model model) {
    model.addAttribute(account);
    Set<Tag> tags = accountService.getTags(account);
    //view에 보여줄 땐 tag entity 타입이 아닌, 문자열로 전송. 문자열 타입의 리스트로. 모델에 아래처럼 담아서 넘김
    model.addAttribute("tags",tags.stream().map(Tag::getTitle) //title만 가져와 문자열로 변경
                           .collect(Collectors.toList())); //문자열을 수집, 리스트로 변환
    return "account/settings/tags";
}
```

받아온 리스트를 html 에 표현할 때 타임리프가 제공하는 스트링 유틸 사용

```html
<input id="tags" type="text" name="tags" th:value="${#strings.listJoin(tags, ',')}"
                           class="tagify-outside" aria-describedby="tagHelp" placeholder='write tags to add below'/>
<!-- th:value="${#strings.listJoin(tags, ',')}" 처럼 작성하여 리스트에 들어있는 데이터를 각각 표현 가능 -->
```

태그 전체 목록을 whiteList로 제공

```java
// AccountSettingsController.java
// 태그 목록을 whiteList로 제공, 목록을 다 가져온 후 스트림으로 매핑해서 type이 tag인데 string(title) type으로 변환, 그리고 List로 변환
List<String> allTags = tagRepository.findAll().stream().map(Tag::getTitle).collect(Collectors.toList());
// 위 리스트는 JAVA 객체에 있는 List 타입, JSON으로 변경하려면 ObjectMapper를 사용 (Spring Boot에 기본적으로 의존성이 들어있음)
model.addAttribute("whitelist", objectMapper.writeValueAsString(allTags));
// ObjectMapper는 @RequestBody 등 JSON을 파싱받고 JSON으로 내보낼 때 사용하는 핵심적인 인스턴스
```

whiteList 표현

```html
<div id="whitelist" name="whitelist" th:text="${whitelist}" hidden></div>
<!-- sciprt tagify 내용에 추가 -->
whitelist: JSON.parse(document.querySelector("#whitelist").textContent),
```

TEST CODE 작성

```java
//AccountSettingsControllerTest.java
@WithUserDetails(value="usernick", setupBefore = TestExecutionEvent.TEST_EXECUTION)
@DisplayName("계정의 태그 수정 폼")
@Test
void updateTagsForm() throws Exception {
    mockMvc.perform(get("/account/settings/tags"))
        .andExpect(view().name("account/settings/tags"))
        .andExpect(model().attributeExists("account"))
        .andExpect(model().attributeExists("whitelist"))
        .andExpect(model().attributeExists("tags"));
}

@WithUserDetails(value="usernick", setupBefore = TestExecutionEvent.TEST_EXECUTION)
@DisplayName("계정에 태그 추가")
@Test
void addTag() throws Exception {
    TagForm tagForm = new TagForm();
    tagForm.setTagTitle("newTag");

    mockMvc.perform(post("/account/settings/tags/add")
                    .contentType(MediaType.APPLICATION_JSON) // 요청 안에 파라미터가 아닌 본문으로 들어옴, 타입은 JSON 문자열 (TagForm 객체가 JSON 으로 변환한 모습)
                    .content(objectMapper.writeValueAsString(tagForm)) // {"tagTitle" : "newTag"} 이렇게 확인을 해야하는데, 프로퍼티가 많아지면 "\ 이런식으로 작성하기 힘드니 objectMapper를 사용
                    .with(csrf()) // post 요청에 필요
                   ).andExpect(status().isOk());

    Tag newTag = tagRepository.findByTitle("newTag");
    assertNotNull(newTag);
    assertTrue(accountRepository.findByNickname("usernick").getTags().contains(newTag)); //처음에 테스트를 진행하면 오류가 발생할 수 있음. 왜냐면 검색하려는 객체가 트랜잭션이 없기에 detached 상태라 추가적으로 정보를 가져올 수 없음, 트랜잭션 필요
```

<hr>

<h3>지역도메인</h3>

도메인 생성

```java
@Entity
@Getter @Setter @EqualsAndHashCode(of = "id")
@Builder @NoArgsConstructor @AllArgsConstructor
public class Zone {
    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String city;

    @Column(nullable = false)
    private String localNameOfCity;

    @Column(nullable = true)
    private String province;
}
```

데이터 초기화 작업

[사이트](https://en.wikipedia.org/wiki/List_of_cities_in_South_Korea) 에 들어가 내용을 복사 후, [Google Docs](https://docs.google.com/spreadsheets/u/0/) 스프레드 시트 파일을 생성

값을 붙여넣고 .csv로 파일 저장하여 resources 밑에 넣어줌

```tex
Andong,안동시,North Gyeongsang
Ansan,안산시,Gyeonggi
Anseong,안성시,Gyeonggi
```

위 처럼 보여지는 데이터를 넣을건데, 스프링 부트에 데이터를 넣을 수 있는 지점이 여러 개 있음. [ApplicationRunner나, CommandLineRunner](https://www.daleseo.com/spring-boot-runners/), [Application Listener](https://jinseongsoft.tistory.com/247) 등 애플리케이션이 구동 됐을 때, 메소드를 실행하면서 데이터를 넣음

그 중 PostConstruct 사용

```java
@Service
@Transactional
@RequiredArgsConstructor
public class ZoneService {
    private final ZoneRepository zoneRepository;

    @PostConstruct // @PostConstruct 는 bean이 만들어진 이후 실행되는 지점
    public void initZoneData() throws IOException {
        if (zoneRepository.count() == 0) {
            Resource resource = new ClassPathResource("zones_kr.csv"); // 저장한 파일
            List<Zone> zoneList = Files.readAllLines( // 모든 라인을 객체로 읽어옴
                resource.getFile().toPath(), StandardCharsets.UTF_8)
                .stream().map(line -> {
                        String[] split = line.split(",");
                        return Zone.builder().city(split[0])
                            .localNameOfCity(split[1]).province(split[2]).build();
                    }).collect(Collectors.toList());
            zoneRepository.saveAll(zoneList);
        }
    }
}
```

관심주제와 다른 점은 기존 저장된 데이터를 whitelist로 사용, 새 데이터 추가,삭제 불가능

<hr>
<h3>Mail 설정</h3>

properties에 메일 설정을 해주면 JavaMailSender bean 등록을 해줌

```properties
# application-dev.properites
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.starttls.enable=true
```

```java
//dev 환경
@Slf4j // error 났을 경우 logging 하기 위해 추가
@Profile("dev")
@Component
@RequiredArgsConstructor
public class HtmlEmailService implements EmailService { // EmailService 는 개발(html)&로컬(console) 환경 모두 사용하기 위해 추상화 한 interface
    private final JavaMailSender javaMailSender;

    @Override
    public void sendEmail(EmailMessage emailMessage) {
        MimeMessage mimeMessage = javaMailSender.createMimeMessage();
        // mimeMessage.setText("text","charset"); 설정해주는데, 매번 같은 값을 주기 번거로워 MimeMessageHelper를 설정
        try {
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, false, "UTF-8"); // 헬퍼가 감쌀 mimeMessage, 메세지가 멀티파트를 전송하는지 여부, charset 설정
            mimeMessageHelper.setTo(emailMessage.getTo()); // 수신자
            mimeMessageHelper.setSubject(emailMessage.getSubject()); // 메일 제목
            mimeMessageHelper.setText(emailMessage.getMessage(), true); // 메일 본문 (두 번째 파라미터는 HTML일 경우 true)
            javaMailSender.send(mimeMessage); // 전송
            log.info("sent email: {}", emailMessage.getMessage());
        } catch (MessagingException e) {
            log.error("failed to send email", e);
            throw new RuntimeException(e); // 해당 에러가 발생하면 트랜잭션으로 인해 데이터 롤백이 발생
        }
    }
}
//local 환경
@Slf4j
@Profile({"local","test"})
@Component
public class ConsoleEmailService implements EmailService{
    @Override
    public void sendEmail(EmailMessage emailMessage) {
        log.info("sent email: {}"+emailMessage.getMessage());
    }
}
```

```java
public interface EmailService {
    void sendEmail(EmailMessage emailMessage);
}

@Data
@Builder
public class EmailMessage {
    private String to;
    private String subject;
    private String message;
}
```

<hr>

<h3>EmailService 사용</h3>

```java
// AccountService.java
public void sendSignUpConfirmEmail(Account newAccount) {
    Context context = new Context();
    context.setVariable("link", "/check-email-token?token="+ newAccount.getEmailCheckToken()+
                        "&email="+ newAccount.getEmail());
    context.setVariable("nickname", newAccount.getNickname());
    context.setVariable("linkName", "이메일 인증하기");
    context.setVariable("message", "트래블위드 서비스를 사용하려면 링크를 클릭하세요.");
    context.setVariable("host", appProperties.getHost());
    String message = templateEngine.process("mail/simple-link", context);

    // EmailService 사용 (dev, local 환경 모두 사용 가능)
    EmailMessage emailMessage = EmailMessage.builder()
        .to(newAccount.getEmail())
        .subject("트래블위드, 회원 가입 인증")
        .message(message)
        .build();

    emailService.sendEmail(emailMessage);
}
```

HTML로 메일 전송 (타임리프가 제공하는 templateEngine 사용)

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>트래블위드</title>
</head>
<body>
<div>
    <p>안녕하세요. <span th:text="${nickname}"></span>님</p>
    <h2 th:text="${message}">메시지</h2>
    <div>
        <a th:href="${host + link}" th:text="${linkName}">Link</a>
        <p>링크가 동작하지 않는 경우에는 아래 URL을 웹브라우저에 복사해서 붙여 넣으세요.</p>
        <small th:text="${host + link}"></small>
    </div>
</div>
<footer>
    <small>트래블위드&copy; 2022</small>
</footer>
</body>
</html>
```

```java
// AccountService.java
public void sendSignUpConfirmEmail(Account newAccount) {
    Context context = new Context(); // 타임리프가 제공, model 역할
    context.setVariable("link", 
                        "/check-email-token?token="+ newAccount.getEmailCheckToken()+
                        "&email="+ newAccount.getEmail());
    context.setVariable("nickname", newAccount.getNickname());
    context.setVariable("linkName", "이메일 인증하기");
    context.setVariable("message", "트래블위드 서비스를 사용하려면 링크를 클릭하세요.");
    context.setVariable("host", appProperties.getHost()); // properties에 각 설정에 맞는 도메인을 작성하여 사용
    String message = templateEngine.process("mail/simple-link", context); // 위에 생성한 템플릿

    EmailMessage emailMessage = EmailMessage.builder()
        .to(newAccount.getEmail())
        .subject("트래블위드, 회원 가입 인증")
        .message(message)
        .build();

    emailService.sendEmail(emailMessage);
}
```

properties 값을 사용하기 위한 설정

```java
@Data
@Component
@ConfigurationProperties("app")
public class AppProperties {
    private String host;
}
// .properties
app.host=http://localhost:8080 
```

<hr>
<h3>동행자 모집 등록</h3>

엔티티 생성, 객체 관점에서 Travel과 다른 엔티티의 관계

<table><tr><td rowspan="2">ACCOUNT</td><td><---</td><td rowspan="2">TRAVEL</td><td>---></td><td>TAG</td></tr><tr><td><---</td><td>---></td><td>ZONE</td></tr></table>

TRAVEL과 ACCOUNT에는 2개의 단방향 관계 존재, ACCOUNT는 수정할 부분 없음, 본인 계정에 해당하는 TRAVEL 정보는 연관관계가 없어도 참조 가능 

TAG, ZONE과도 1개의 단방향 관계 존재, 마찬가지로 수정할 부분 없음

```java
@Entity
@Setter @Getter @EqualsAndHashCode
@Builder @NoArgsConstructor @AllArgsConstructor
public class Travel {
    @Id @GeneratedValue
    private Long id;
    @ManyToMany // 관리자는 여러 명일 수 있음
    private Set<Account> managers = new HashSet<>(); // Travel 관리자
    @ManyToMany
    private Set<Account> members = new HashSet<>(); // Travel 회원
    @Column(unique = true)
    private String path;
    private String title;
    private String shortDescription;
    @Lob
    private String fullDescription;
    @Lob
    private String image;
    @ManyToMany
    private Set<Tag> tags = new HashSet<>();// new HashSet<>()을 안 해주면 Getter 호출시
    @ManyToMany
    private Set<Zone> zones = new HashSet<>();
    private LocalDateTime publishedDateTime; // Travel 공개한 시간
    private LocalDateTime closedDateTime; // Travel 종료한 시간
    private LocalDateTime recruitingUpdateDateTime; // Travel 인원 모집 가능 시간
    private boolean recruiting; // Travel 회원 모집 여부
    private boolean published; // Travel 공개 여부
    private boolean closed; // Travel 종료 여부
    private boolean useBanner; // 배너 사용 여부
}
```

FORM 생성 (에디터 설정) [Summernote](https://summernote.org/) npm install summernote

```html
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:300,400,500&display=swap" >
<link rel="stylesheet" href="/node_modules/summernote/dist/summernote-bs4.min.css">
<script src="/node_modules/summernote/dist/summernote-bs4.js"></script>
<script type="application/javascript">
        $(function () {
            $('#fullDescription').summernote({
                fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Noto Sans KR', 'Merriweather'],
                placeholder: '여행의 목적, 일정, 서로 간의 지켜야 할 규칙 등 동행자 모집에 대해 자세히 적어 주세요.',
                tabsize: 2,
                height: 300
            });
        });
</script>
```

컨트롤러

```java
@Controller
@RequiredArgsConstructor
public class TravelController {

    private final TravelService travelService;
    private final ModelMapper modelMapper;
    private final TravelFormValidator travelFormValidator;

    @InitBinder("travelForm")
    public void travelFormInitBinder(WebDataBinder webDataBinder) {
        webDataBinder.addValidators(travelFormValidator);
    }

    @GetMapping("/new-travel")
    public String newTravelForm(@CurrentUser Account account, Model model) {
        model.addAttribute(account);
        model.addAttribute(new TravelForm()); // Travel 화면에 보여줄 정보
        return "travel/form";
    }

    @PostMapping("new-travel")
    public String newTravelSubmit(@CurrentUser Account account, @Valid TravelForm travelForm, Errors errors) {
        if (errors.hasErrors()) {
            return "travel/form";
        }

        Travel newTravel = travelService.createNewTravel(modelMapper.map(travelForm, Travel.class), account);
        return "redirect:/travel/"+ URLEncoder.encode(travelForm.getPath(), StandardCharsets.UTF_8); // path에 한글 값이 들어올 경우 인코딩 필요
    }
}
```

<hr>

<h3>동행자 모집 조회</h3><h4>소개</h4>

```java
// TravelController.java
@GetMapping("/travel/{path}")
public String viewTravel(@CurrentUser Account account, @PathVariable String path, Model model) {
    model.addAttribute(account);
    model.addAttribute(travelRepository.findByPath(path));
    return "travel/view";
}
```

조회 화면에 필요한 정보를 불러오는 쿼리는 현재 5개 발생 (path 검색, 멤버 조회, 매니저 조회, 태그 조회, 지역 조회)

필요한 데이터라면 findByPath 를 호출할 때 left outer join 해서 한 번에 조회

```java
// Travel.java , entityManagerGraph 정의
@NamedEntityGraph(name = "Travel.withAll", attributeNodes = {
        @NamedAttributeNode("tags"),
        @NamedAttributeNode("zones"),
        @NamedAttributeNode("managers"),
        @NamedAttributeNode("members")})

// TravelRepository.java
@EntityGraph(value = "Travel.withAll", type = EntityGraph.EntityGraphType.LOAD) 
// LOAD는 EntityGraph에 명시한 데이터는 EAGER, 나머지는 기본 전략을 따름
    Travel findByPath(String path);
```

<h4>구성원</h4>

```java
// TravelController.java
@GetMapping("/travel/{path}/members")
public String viewTravelMembers(@CurrentUser Account account, @PathVariable String path, Model model) {
    Travel travel = travelService.getTravel(path);
    model.addAttribute(account);
    model.addAttribute(travel);
    return "travel/members";
}
// TravelService.java
public Travel getTravel(String path) {
    Travel travel = travelRepository.findByPath(path);
    return travel;
}
```

```html
<!-- travel/mambers.html -->
<div th:replace="fragments.html :: member-list(members=${travel.managers},isManager=${true})"></div>
<div th:replace="fragments.html :: member-list(members=${travel.members},isManager=${false})"></div>
```

${travel.managers} 형식으로 fragments에 list를 넘겨줄 수 있음

```html
<!-- fragments.html -->
<div th:fragment="member-list (members, isManager)" class="row px-3 justify-content-center">
    <ul class="list-unstyled col-10">
        <li class="media mt-3" th:each="member: ${members}">
            <svg th:if="${#strings.isEmpty(member?.profileImage)}" th:data-jdenticon-value="${member.nickname}" width="45" height="45" class="rounded border bg-light mr-3"></svg>
            <img th:if="${!#strings.isEmpty(member?.profileImage)}" th:src="${member?.profileImage}" width="45" height="45" class="rounded border mr-3"/>
            <div class="media-body">
                <h5 class="mt-0 mb-1"><span th:text="${member.nickname}"></span> <span th:if="${isManager}" class="badge badge-primary">관리자</span></h5>
                <span th:text="${member.bio}"></span>
            </div>
        </li>
    </ul>
</div>
```



